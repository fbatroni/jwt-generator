/*eslint no-bitwise: ["error", { "allow": ["~"] }] */
/*eslint no-implicit-coercion: "off"*/
/*eslint no-ternary: "off"*/
"use strict";

const http = require('./http.js');
const config = require('../config/config.js');
const jwt = require('jsonwebtoken');

module.exports = {
  getUsersPayload: (emailAddress, url, expiresInSeconds) => http.get(`${config.epiAuthTemplate}?email=${emailAddress}`)
    .then(epiqueryResults => JSON.parse(epiqueryResults))
    .then(userMetaInformation => {
      const payload = {};
      const roles = userMetaInformation[0][0];
      const personRecords = userMetaInformation[1];
      const expiresIn = (expiresInSeconds || 3600) * 1000;

      if (personRecords.length === 0) {
        throw new Error("User not found");
      }
      /** The first result should have only one response which is currently our glg-role */
      /*eslint guard-for-in: "off"*/
      for (let key in roles) {
        const cleanedRoleName = key.replace(/_/g, "-").toLowerCase();
        payload[cleanedRoleName] = roles[key];
      }
      personRecords.forEach(personRecord => {
        for (let key in personRecord) {
          if (personRecord[key] === null) {
            delete personRecord[key];
          }
        }
      });
      payload.ids = personRecords;
      /**
       * On Jul 25, 2016 - It was discussed that GLG will consider it an 'error' and
       * bad data if an email address returns multiple person_id -> $role_id matches.
       * The following code will enforce this principle and also add some convenient
       * fields in the token about the user like "cmid"
       *
       * Conversation participants:  SQuince, ASegal, MHuggins, BHudgens
       */
      personRecords.forEach(personRecord => {
        for (let key in personRecord) {
          /*
           * If the payload key already exists - we have a dupe and the condition
           * described above exists.  Each grouping will always have a "personId"
           * because that's the whole point - letting the app know which ID goes
           * with which other id's.  So we skip mapping a person id to a convenience
           * token
           *
           * For example - It is valid for a user to have:
           *
           *   {
           *     personId: 234,
           *     cmId: 4433
           *   },
           *   {
           *     personId: 534,
           *     user: 2343
           *   }
           *
           * We will make a root level token for user AND cmId here.  Apps can use
           * the "ids" property if they want the personid mapping
           */
          if (key === "personId") {
            continue;
          }

          if (payload[key]) {
            // TODO: This needs to be a unique error type to capture to a
            //       special error page that emphasizes user should contact
            //       member solutions
            throw new Error(`User Cannot Login - Too Many Records - ${key}`);
          }
          payload[key] = personRecord[key];
        }
      });
      const token = jwt.sign(payload, config.jwtSecret, { algorithm: "HS256", expiresIn });
      const urlWithToken = ~url.indexOf("?") ? `${url}&jwt=${token}` : `${url}?jwt=${token}`;
      return { token, urlWithToken, url };
    })
    .catch(e => {
      throw e;
    })
};
